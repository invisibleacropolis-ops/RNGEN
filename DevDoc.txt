
The Universal Name Generator: A Design Manual for Godot 4.4


Foreword: The Philosophy of Procedural Naming

Procedural Content Generation (PCG) is fundamentally an exercise in balancing competing forces. At its core, every procedural system navigates the delicate trade-off between authorial control and algorithmic variation.1 A system with total control is merely a static asset, while a system with pure, unconstrained variation produces incoherent noise. The art of PCG lies in designing systems that occupy the vast, fertile ground between these two extremes, generating content that is simultaneously novel, coherent, and fit for a specific purpose.

This manual addresses the procedural generation of one of the most ubiquitous and vital assets in any game world: names. From the designation of a humble NPC to the title of a legendary artifact or the name of a sprawling continent, names infuse a world with identity, lore, and flavor. A game may require thousands of them, spanning dozens of categories and styles. Manually creating such a volume of content is not only laborious but can also lead to creative fatigue and inconsistency. A robust procedural name generator is therefore not a luxury, but an essential tool for modern game development.
The challenge, however, is that no single algorithm can effectively generate every type of name. The technique for creating a plausible, real-world human name is vastly different from that required to generate a guttural, alien-sounding planetary system. A simple list-based approach may suffice for item modifiers, but it cannot produce the unique, pronounceable names required for a fantasy race.

For this reason, this manual champions a hybrid approach to name generation. By designing a unified framework that incorporates multiple, distinct generation algorithms, a developer gains the ability to select the precise balance of control and variation for any given task.2 This manual will guide you through the design and implementation of such a system in the Godot 4.4 engine. The goal is not to provide a collection of disparate scripts, but to architect a single, universal, and extensible framework—a NameGenerator that can serve all the naming needs of a project, present and future. We will explore the theoretical underpinnings and practical GDScript implementation of four core methodologies: Dictionary/Wordlist Combination, Syllable Chaining, Template-Based Generation, and Markov Chains, all built upon a foundation of deterministic, seed-based generation to ensure reproducibility and control. The final result will be a powerful, modular system that embodies the core philosophy of procedural generation: the artful management of chaos.

Part I: Foundational Architecture & Core Systems

Before a single name can be generated, a robust and extensible foundation must be laid. This section details the architectural pillars of the Universal Name Generator. The design choices presented here prioritize modularity, data-driven design, and deterministic control. By establishing a clean, decoupled, and well-managed core, the subsequent implementation of individual generation algorithms becomes a straightforward process of extension rather than a complex series of modifications. This foundational work is critical to creating a system that is not only powerful but also maintainable and scalable throughout a project's lifecycle.

Chapter 1: Designing the Core Generator Framework


1.1. The Case for a Unified Architecture

In the Godot Asset Library and various online repositories, one can find numerous name generator scripts.4 While many are functional for their specific, narrow purpose—such as generating a fantasy name or combining words from a list—they often exist as isolated, standalone tools. Integrating several such scripts into a single project can lead to a fragmented and inconsistent codebase. Each script may have its own API, its own method of handling data, and its own approach to randomness, resulting in a system that is difficult to manage and extend.

A universal name generator demands a more holistic approach. The architectural goal is to create a single, cohesive system with a unified entry point. All name generation requests, regardless of their complexity or the underlying algorithm required, should be channeled through a single, consistent interface, such as NameGenerator.generate(...). This function will not be a monolithic block of conditional logic but a clean gateway that directs requests to the appropriate specialized logic. This unified architecture ensures consistency, simplifies integration with other game systems, and provides a clear, single point of control for all naming operations within the project.

1.2. The Strategy Design Pattern: A Perfect Fit for PCG

To achieve this unified yet modular system, the Strategy design pattern serves as the ideal architectural foundation.8 This behavioral design pattern enables selecting an algorithm at runtime. It involves defining a family of algorithms, encapsulating each one into a separate class, and making their objects interchangeable.10

In the context of our name generator, each distinct generation technique (Wordlist Combination, Syllable Chaining, Markov Chains, etc.) will be implemented as a separate "Strategy." We will define a base GeneratorStrategy class that establishes a common interface—a generate(config, rng) method. Each specific generator, such as WordlistStrategy or MarkovStrategy, will then extend this base class and provide its own unique implementation of the generate method.

This approach offers several profound advantages:
* Extensibility: Adding a new name generation technique in the future becomes trivial. One simply needs to create a new class that inherits from GeneratorStrategy and implements the generate method. The core NameGenerator system remains entirely untouched, adhering to the Open/Closed Principle.11
* Single Responsibility Principle (SRP): Each strategy class has one, and only one, responsibility: to correctly implement its specific naming algorithm. This makes the code for each algorithm focused, easier to understand, and simpler to debug.9

* Decoupling: The main NameGenerator (the "Context" in pattern terminology) is completely decoupled from the concrete implementation of any given strategy. It only needs to know how to call the common generate method on the strategy object it is given.

This architectural choice finds parallels in other domains of procedural content generation. Advanced procedural map generation, for instance, often involves layering multiple distinct algorithms: one for generating a base heightmap (e.g., Perlin noise), another for carving rivers (e.g., random walkers), and a third for placing objects based on rules.13 This concept of composing modular, specialized algorithms is a powerful theme in PCG. The Strategy pattern is the software engineering embodiment of this principle, allowing us to treat each name generation algorithm as a self-contained, interchangeable module that can be selected, or even chained together, to produce complex results.

1.3. Architecting the NameGenerator Singleton

The central access point for our entire system will be the NameGenerator script. In Godot, the most effective way to make a system globally accessible is to configure it as an Autoload, or Singleton.10 This ensures that a single instance of the NameGenerator is available from anywhere in the project's code via a global name (e.g., NameGenerator).

The primary role of this singleton is not to contain the generation logic itself, but to act as the "Context" within the Strategy pattern. It will orchestrate the generation process by delegating requests to the appropriate strategy.

Its core components will be:
1. A Strategy Registry: A Dictionary that maps a unique string identifier (e.g., "wordlist", "markov") to an instantiated object of the corresponding strategy class. This registry is populated once when the game starts.
2. The generate() Method: The public-facing API for the entire system. This method will receive a configuration object that specifies which strategy to use, along with all necessary data and parameters.
3. Delegation Logic: Inside the generate() method, the singleton will look up the requested strategy in its registry and call that strategy's generate() method, passing along the configuration and a dedicated RandomNumberGenerator instance.

GDScript


# NameGenerator.gd (Autoload Singleton)
extends Node

# The registry will hold instances of our strategy classes.
var _strategies: Dictionary = {}

# We will define strategy classes in separate files.
const WordlistStrategy = preload("res://name_generator/strategies/wordlist_strategy.gd")
const SyllableChainStrategy = preload("res://name_generator/strategies/syllable_chain_strategy.gd")
const TemplateStrategy = preload("res://name_generator/strategies/template_strategy.gd")
const MarkovChainStrategy = preload("res://name_generator/strategies/markov_chain_strategy.gd")

func _ready() -> void:
    # Populate the strategy registry at startup.
    _strategies["wordlist"] = WordlistStrategy.new()
    _strategies["syllable"] = SyllableChainStrategy.new()
    _strategies["template"] = TemplateStrategy.new()
    _strategies["markov"] = MarkovChainStrategy.new()
    # To add a new generator, one would simply add a line here.

# The main public API for the entire system.
func generate(config: Dictionary) -> String:
    # 1. Validate the configuration.
    if not config.has("strategy") or not _strategies.has(config.strategy):
        push_error("NameGenerator: Invalid or missing 'strategy' in configuration.")
        return ""

    if not config.has("seed"):
        push_error("NameGenerator: Missing 'seed' in configuration.")
        return ""

    # 2. Get a deterministic RNG instance for this specific call.
    # The RNGManager (detailed in Chapter 3) provides isolated random streams.
    var rng = RNGManager.get_rng(config.seed)

    # 3. Select the appropriate strategy from the registry.
    var strategy = _strategies[config.strategy]

    # 4. Delegate the generation task to the selected strategy.
    return strategy.generate(config, rng)


1.4. The Configuration Object Pattern

To maintain a clean and extensible API, all calls to NameGenerator.generate() will pass a single Dictionary as a configuration object. This avoids the "parameter creep" that would occur if every possible option for every strategy were added as an argument to the function.
A typical configuration object might look like this:

GDScript


var config = {
    "strategy": "template",
    "seed": "player_character_name_01",
    "template_string": "[title] of [place]",
    "sub_generators": {
        "title": {
            "strategy": "wordlist",
            "seed": "player_character_name_01_title",
            "wordlist_path": "res://data/wordlists/titles/heroic_titles.tres"
        },
        "place": {
            "strategy": "markov",
            "seed": "player_character_name_01_place",
            "model_path": "res://data/markov_models/fantasy_places.tres"
        }
    }
}

var character_name = NameGenerator.generate(config)

This pattern makes the API incredibly flexible. New strategies can define their own required configuration keys without forcing any changes to the NameGenerator.generate() method signature. It also makes the generation requests self-documenting and easy to serialize or store if needed.
The following table provides a high-level overview of the core generation techniques that will be implemented as strategies, highlighting their distinct characteristics and primary use cases. This framework helps in deciding which strategy is the most appropriate tool for a given naming task.
Table 1: Comparison of Name Generation Techniques
---------------------------------------------
| |Technique | |Output Style | |Performance Cost (Generation) | |Data Dependency | |Primary Use Case | |Controllability |
---------------------------------------------
| |Wordlist Combination | |Structured, predictable, limited vocabulary. | |Very Low | |Requires curated wordlists. | |Item names, quest titles, simple place names (e.g., "Sword of Courage"). | |High |
---------------------------------------------
| |Syllable Chaining | |Novel, pronounceable, stylistically consistent. | |Low | |Requires lists of syllables (prefixes, middles, suffixes). | |Fantasy/sci-fi character names, alien species, unique locations. | |Medium |
---------------------------------------------
| |Markov Chains | |Stylistically mimics source data, can be highly varied. | |Low | |Requires a pre-trained model derived from a large name list. | |Generating names that "feel" like they belong to a specific culture or race. | |Medium-Low |
---------------------------------------------
| |Template-Based | |Highly structured, compositional. | |Low (depends on sub-generators) | |Relies on other generators and their data sources. | |Complex titles, character full names, structured descriptions. | |Very High |

Chapter 2: Data Management with Godot Resources

The quality and organization of the source data—the wordlists, syllable sets, and trained models—are as crucial as the generation algorithms themselves. A poorly designed data pipeline can lead to brittle code, difficult workflows, and issues with exported projects. This chapter advocates for a data-oriented approach centered on Godot's native Resource system, a powerful feature that provides editor integration, type safety, and efficient loading.

2.1. The Problem with Raw Data Files (.txt, .csv, .json)

A common first approach to managing wordlists is to store them in simple text files (.txt), comma-separated value files (.csv), or JSON files (.json). While seemingly straightforward, this method introduces significant friction and potential for error when used within Godot.19
Loading these files at runtime requires using the FileAccess object.20 This involves manually opening the file, reading its contents line by line or as a whole string, and then parsing that string into a usable data structure like an
Array or Dictionary.21 This process has several drawbacks:
* Parsing Overhead: Every time the data is needed, the raw text must be parsed, which is computationally less efficient than loading a pre-parsed binary or text-based resource.
* Lack of Editor Integration: There is no direct way to view or edit the contents of a .txt or .csv file within the Godot editor's Inspector. This forces designers and writers to use external tools, breaking the development workflow.
* Exporting Issues: By default, Godot does not export unrecognized file types like .txt or .json into the final game package (.pck). Developers must remember to manually configure the export settings to include these files, a common source of bugs where the game works in the editor but fails in the exported build.23 While Godot has built-in helpers for JSON, the official documentation itself advises against using it for save files or internal data structures due to its limited data types and cumbersome conversion process.19

2.2. The Superiority of Custom Resources

Godot provides a far superior solution: the Resource system. Nearly everything in Godot that holds data, from textures and meshes to animation libraries, is a Resource.27 Developers can create their own
Custom Resources by simply creating a script that extends the Resource class.27
Using Custom Resources for our wordlists and data models offers transformative benefits:
* Direct Editor Integration: By using the @export annotation on variables within a custom resource script, the data becomes directly editable in the Godot Inspector. A designer can create a new WordListResource, and an intuitive interface for adding, editing, and removing words will appear automatically.29
* Type Safety: Godot's static typing can be used to ensure data integrity. An exported variable can be typed as Array, preventing non-string data from being entered and providing better code completion and error checking.29
* Effortless Loading: Godot handles the serialization and loading of resources automatically. Data is loaded with a simple load("res://path/to/my_data.tres") or preload(...) call. There is no manual file handling or parsing required.27
* Reusability and Referencing: A single resource file (saved as a .tres for human-readability or .res for binary efficiency) can be referenced by multiple different nodes or other resources. If the data in the file is updated, all objects referencing it will see the change automatically.28
This approach also serves as a powerful decoupling mechanism. Instead of hard-coding file paths into generator logic, scripts can simply export a variable of a specific resource type (e.g., @export var word_list: WordListResource). This decouples the algorithm from the specific data it operates on. A developer or designer can then drag and drop any compatible .tres file into the Inspector slot, allowing for rapid prototyping and iteration without ever touching the code.8 This shift from file paths to resource references is a fundamental improvement in architectural robustness and designer-friendliness.

2.3. Implementation: WordListResource and SyllableSetResource

We will define two primary custom resources to serve our initial generator strategies. These scripts should be placed in a logical location, such as res://name_generator/resources/.
First, the WordListResource, which is a simple container for an array of strings.

GDScript


# res://name_generator/resources/word_list_resource.gd
class_name WordListResource extends Resource

## An array of words or phrases used for generation.
@export var words: Array

Second, the SyllableSetResource, which is structured to hold the components for the Syllable Chaining strategy.

GDScript


# res://name_generator/resources/syllable_set_resource.gd
class_name SyllableSetResource extends Resource

## Syllables that can appear at the beginning of a name.
@export var prefixes: Array

## Syllables that can appear in the middle of a name.
@export var middles: Array

## Syllables that can appear at the end of a name.
@export var suffixes: Array

With these scripts defined, new data assets can be created directly in the FileSystem dock by right-clicking, selecting "New Resource...", and searching for WordListResource or SyllableSetResource. The resulting .tres file can then be selected and its data populated in the Inspector.

2.4. Project Data Structure

To maintain clarity and organization as the number of data files grows, a standardized folder structure is essential. All name generation data should be stored under a top-level data directory.



res://
└─ data/
   ├─ markov_models/
   │  ├─ fantasy_dwarven_male.tres
   │  └─ scifi_alien_planet.tres
   ├─ syllable_sets/
   │  ├─ fantasy_elven.tres
   │  └─ fantasy_orcish.tres
   └─ wordlists/
      ├─ objects/
      │  ├─ weapon_adjectives.tres
      │  └─ weapon_types_swords.tres
      └─ people/
         ├─ fantasy_elf_female_names.tres
         └─ real_world_surnames_english.tres

This structure separates data by type (models, syllables, wordlists) and then further by domain and specific category, making it easy to locate and manage any data asset required by the NameGenerator.

Chapter 3: Mastering Determinism: Seed & State Management


3.1. The Need for Determinism

In the context of procedural generation, "random" does not mean "unpredictable." A core requirement for robust PCG systems is determinism: the ability to produce the exact same output given the exact same input.34 A function is deterministic when a specific input always yields the same output. The input that controls the output of a pseudo-random process is called a
seed.35
Determinism is critical for several reasons in game development:
* Reproducibility and Debugging: If a bug occurs in a procedurally generated level or with a procedurally named item, being able to reproduce the exact conditions by reusing the original seed is invaluable for debugging.34
* Content Sharing: Players can share seeds with each other to experience the same generated world, level layout, or character, fostering community and competitive play (e.g., seeded speedruns).34
* Efficient Save Systems: For complex procedural systems, it is often more efficient to save the initial seed and any subsequent player actions than to save the entire state of the generated world. The world can be regenerated from the seed upon loading.34

3.2. Godot's RandomNumberGenerator Class

Godot provides global functions for randomness (randi(), randf(), randomize(), seed()). While convenient for simple cases, these functions are a critical architectural flaw for a complex, deterministic system. They all operate on a single, shared, global random number stream.
This creates a problem of state contamination.34 If a system for generating NPC names calls
randi(), it advances the global random stream. If a system for generating item properties then calls randi(), the result it gets is dependent on whether the NPC name generator was called first. This tight, implicit coupling between unrelated systems makes true, isolated determinism impossible. If a developer changes the number of random calls in one system, it can have cascading, unpredictable effects on every other procedural system in the game.
The solution is to abandon the global random functions entirely and exclusively use instances of the RandomNumberGenerator class.38 Each
RandomNumberGenerator object is a self-contained random stream with its own seed and internal state. This provides perfect isolation, ensuring that the sequence of numbers from one generator instance is completely independent of all others.

3.3. Architecting the RNGManager Singleton

Achieving robust determinism is not merely a matter of calling a function; it is an architectural property that must be designed into the system from the ground up. To manage this, we will create another autoloaded singleton: RNGManager.gd. This manager will centralize all control over randomness in the project.
The RNGManager will have two primary responsibilities:
1. Managing the Master Seed: It will hold a single master seed for the entire game session. This seed can be generated randomly on startup, or set from player input or a save file.
2. Providing Named, Seeded RNG Instances: Instead of creating RandomNumberGenerator instances directly, other scripts will request them from the RNGManager. The manager will maintain a dictionary of these instances, ensuring that each uniquely named request receives its own deterministic, isolated random stream.
The seeding strategy is crucial. Each named RNG instance will be seeded with a value derived from both the master seed and its own unique name. A simple and effective method is to combine the master seed with the hash of the name.34

GDScript


# RNGManager.gd (Autoload Singleton)
extends Node

var _master_seed: int = 0
var _rng_instances: Dictionary = {}

# This should be called once at the start of the game or when loading.
func set_master_seed(seed_value: int) -> void:
    _master_seed = seed_value
    # Clear existing instances to ensure they are re-seeded if the master seed changes.
    _rng_instances.clear()

# The main public API for accessing isolated RNG streams.
func get_rng(stream_name: String) -> RandomNumberGenerator:
    if not _rng_instances.has(stream_name):
        # If this is the first request for this stream, create and seed a new RNG.
        var new_rng = RandomNumberGenerator.new()
        # Combine the master seed with the hash of the stream name for a unique,
        # deterministic seed for this specific stream.
        var stream_seed = _master_seed + hash(stream_name)
        new_rng.seed = stream_seed
        _rng_instances[stream_name] = new_rng
    
    return _rng_instances[stream_name]

# Helper to generate a random master seed on new game start.
func randomize_master_seed() -> void:
    var temp_rng = RandomNumberGenerator.new()
    temp_rng.randomize()
    set_master_seed(temp_rng.seed)

# Functions for saving and loading the state of all RNGs.
func get_all_states() -> Dictionary:
    var all_states = {}
    for stream_name in _rng_instances:
        all_states[stream_name] = _rng_instances[stream_name].state
    return all_states

func set_all_states(states: Dictionary) -> void:
    for stream_name in states:
        if _rng_instances.has(stream_name):
            _rng_instances[stream_name].state = states[stream_name]


3.4. State Management for Save/Load

Simply re-seeding a RandomNumberGenerator on game load is not enough to guarantee perfect reproducibility. Seeding only resets the generator to the beginning of its sequence. If a generator has already been used several times before the game was saved, re-seeding it will cause it to repeat those initial numbers, leading to different outcomes than what would have occurred in the original session.
To solve this, we must use the state property of the RandomNumberGenerator class.34 The
state is an integer that represents the generator's exact current position within its pseudo-random sequence.
The correct save/load procedure is therefore:
1. On Save:
	* Save the _master_seed from the RNGManager.
	* Call a function on the RNGManager (like get_all_states() above) to retrieve a dictionary containing the current state of every named RNG instance it has created.
	* Save this dictionary to the save file.
2. On Load:
	* Load the _master_seed and pass it to RNGManager.set_master_seed(). This re-creates all the RNG instances with their original seeds.
	* Load the dictionary of states.
	* Call a function on the RNGManager (like set_all_states() above) to iterate through the loaded states and restore the state property of each corresponding RNG instance.
This two-step process ensures that upon loading, every random stream in the game is in the exact same condition it was in when the game was saved, guaranteeing perfect deterministic continuity.

Part II: Implementing the Generation Strategies

With the foundational architecture for the NameGenerator, data management, and deterministic randomness established, this section focuses on the practical implementation of the individual generation algorithms. Each of the following chapters will detail a specific GeneratorStrategy, covering its underlying concept, use cases, data requirements, and a complete implementation in GDScript. These strategies are the modular, interchangeable components that give the Universal Name Generator its power and flexibility.

Chapter 4: Strategy 1: Dictionary & Wordlist Combination


4.1. Concept and Use Cases

The Dictionary & Wordlist Combination strategy is the most straightforward method of procedural generation. It operates on a simple principle: constructing a name or phrase by selecting words from one or more predefined lists and concatenating them.40 This technique offers a high degree of authorial control, as the entire vocabulary of possible outputs is explicitly defined in the source wordlists.
This strategy is ideal for generating content that requires a clear structure and a controlled vocabulary. It excels at creating names for items, quests, or simple locations where creativity is desired but must be constrained within established conventions.
Common Use Cases:
* Item Names: Combining lists of materials, qualities, and item types (e.g., + `[Iron]` +).
* Quest Titles: Stitching together verbs, nouns, and locations (e.g., `` + [the Lost Amulet] + [of Gorgon]).
* Simple Place Names: Combining adjectives and geographical features (e.g., +).
* Character Epithets: Appending a title from one list to a name from another (e.g., [Aragorn] + ``).

4.2. WordlistStrategy.gd Implementation

The implementation of this strategy is simple. It will be a new script that extends a base GeneratorStrategy class. This base class ensures that all our strategies adhere to the same interface, making them interchangeable.
First, the base strategy script:

GDScript


# res://name_generator/strategies/generator_strategy.gd
class_name GeneratorStrategy extends RefCounted

# All strategies must implement this method.
# 'config' is a Dictionary containing all parameters for the generation.
# 'rng' is a pre-seeded RandomNumberGenerator instance for deterministic results.
func generate(config: Dictionary, rng: RandomNumberGenerator) -> String:
    # This base method should be overridden by subclasses.
    push_error("generate() method not implemented in the strategy.")
    return ""

Now, the WordlistStrategy itself. It expects the config dictionary to contain a key wordlist_paths, which is an array of strings pointing to the WordListResource files to use.

GDScript


# res://name_generator/strategies/wordlist_strategy.gd
class_name WordlistStrategy extends GeneratorStrategy

func generate(config: Dictionary, rng: RandomNumberGenerator) -> String:
    if not config.has("wordlist_paths") or not config.wordlist_paths is Array:
        push_error("WordlistStrategy: Configuration missing 'wordlist_paths' array.")
        return ""

    var name_parts: Array =
    for list_path in config.wordlist_paths:
        var word_list_resource: WordListResource = load(list_path)
        if word_list_resource and not word_list_resource.words.is_empty():
            # Select a random word from the list.
            var random_word = word_list_resource.words.pick_random()
            name_parts.append(random_word)
        else:
            push_warning("WordlistStrategy: Could not load or found empty wordlist at '%s'." % list_path)
    
    # Join the selected parts with a space. This could be made configurable.
    return " ".join(name_parts)

Note on pick_random(): The Array.pick_random() method uses the global random number generator. For our deterministic system, this is unacceptable. We must replace this with a custom function that uses the provided rng instance. This can be a static helper function.

GDScript


# In a utility script, e.g., res://utils/ArrayUtils.gd
class_name ArrayUtils

static func pick_random_deterministic(array: Array, rng: RandomNumberGenerator):
    if array.is_empty():
        return null
    var index = rng.randi_range(0, array.size() - 1)
    return array[index]

# Updated WordlistStrategy.gd generate method:
#...
var random_word = ArrayUtils.pick_random_deterministic(word_list_resource.words, rng)
#...


4.3. Advanced Technique: Weighted Selection

In many cases, a simple uniform random selection is insufficient. For loot systems, for example, it is desirable for certain modifiers (e.g., "Legendary") to appear far less frequently than others (e.g., "Common"). This can be achieved through weighted random selection.
To support this, we first enhance our WordListResource to store not just words, but dictionaries containing a word and its associated weight.

GDScript


# res://name_generator/resources/word_list_resource.gd (Enhanced)
class_name WordListResource extends Resource

# We now use an array of dictionaries to store entries with weights.
# Example entry: {"word": "Common", "weight": 10.0}
# Example entry: {"word": "Legendary", "weight": 0.5}
@export var weighted_words: Array

Next, we create a utility function to perform the weighted selection. This function calculates the total weight of all items, picks a random number within that range, and then iterates through the items to find which "slice" the random number falls into. This is analogous to Godot's built-in rand_weighted function but works with our custom resource structure.38

GDScript


# In res://utils/ArrayUtils.gd
class_name ArrayUtils

#... (previous functions)

static func pick_weighted_random_deterministic(weighted_array: Array, rng: RandomNumberGenerator) -> String:
    if weighted_array.is_empty():
        return ""

    var total_weight: float = 0.0
    for item in weighted_array:
        if item.has("weight") and item.weight is float:
            total_weight += item.weight
    
    if total_weight <= 0.0:
        # Fallback to uniform random if weights are invalid or zero.
        var random_item = pick_random_deterministic(weighted_array, rng)
        return random_item.get("word", "")

    var random_value = rng.randf_range(0.0, total_weight)
    var cumulative_weight: float = 0.0
    
    for item in weighted_array:
        if item.has("weight") and item.weight is float:
            cumulative_weight += item.weight
            if random_value < cumulative_weight:
                return item.get("word", "")
    
    # Fallback in case of floating point inaccuracies.
    return weighted_array.back().get("word", "")

Finally, the WordlistStrategy can be updated to use this new function when appropriate, perhaps controlled by a flag in the configuration object. This provides a powerful mechanism for controlling the probability distribution of generated names.

Chapter 5: Strategy 2: Syllable Chaining & Phonetic Cohesion


5.1. Concept and Use Cases

Syllable Chaining is a classic procedural generation technique for creating novel yet pronounceable and stylistically coherent names. It is the cornerstone of name generation in many fantasy and science-fiction settings.41 Instead of combining whole words, this method constructs names from smaller phonetic components—typically categorized as prefixes, middle parts (infixes), and suffixes.
By curating lists of these syllables to fit a particular theme (e.g., harsh, guttural sounds for Orcs; soft, melodic sounds for Elves), a generator can produce a vast number of unique names that all feel like they belong to the same fictional language or culture.
Common Use Cases:
* Fantasy Character Names: Generating names for races like Elves, Dwarves, Orcs, etc.
* Sci-Fi Names: Creating names for alien species, star systems, or futuristic technologies.
* Magic Spells: Inventing incantations that sound mystical and powerful.
* Unique Place Names: Crafting names for fantastical cities or regions that are not based on real-world combinations.

5.2. SyllableChainStrategy.gd Implementation

This strategy will use the SyllableSetResource defined in Chapter 2, which contains separate arrays for prefixes, middles, and suffixes. The generate function will assemble a name by picking one component from each required list.

GDScript


# res://name_generator/strategies/syllable_chain_strategy.gd
class_name SyllableChainStrategy extends GeneratorStrategy

func generate(config: Dictionary, rng: RandomNumberGenerator) -> String:
    if not config.has("syllable_set_path"):
        push_error("SyllableChainStrategy: Configuration missing 'syllable_set_path'.")
        return ""

    var syllable_set: SyllableSetResource = load(config.syllable_set_path)
    if not syllable_set:
        push_error("SyllableChainStrategy: Failed to load SyllableSetResource from '%s'." % config.syllable_set_path)
        return ""

    # Check for empty lists to avoid errors.
    if syllable_set.prefixes.is_empty() or syllable_set.suffixes.is_empty():
        push_error("SyllableChainStrategy: Prefixes or suffixes list is empty in '%s'." % config.syllable_set_path)
        return ""

    var name_parts: Array =

    # 1. Add a prefix.
    name_parts.append(ArrayUtils.pick_random_deterministic(syllable_set.prefixes, rng))

    # 2. Add a variable number of middle syllables.
    # This can be controlled by the config.
    var middle_syllable_count = config.get("middle_syllables", rng.randi_range(0, 1))
    if not syllable_set.middles.is_empty():
        for i in range(middle_syllable_count):
            name_parts.append(ArrayUtils.pick_random_deterministic(syllable_set.middles, rng))

    # 3. Add a suffix.
    name_parts.append(ArrayUtils.pick_random_deterministic(syllable_set.suffixes, rng))

    # 4. Concatenate and format the name (e.g., capitalize).
    return "".join(name_parts).capitalize()


5.3. Heuristic Syllabification: Creating Your Own Data

The primary challenge of syllable chaining is not the algorithm, but the acquisition of high-quality, thematically consistent syllable data. While some lists can be found online, the most powerful approach is to generate your own syllable sets from existing lists of names that already have the desired "feel."
Linguistically accurate syllabification is an exceptionally complex, and largely unsolved, problem in computational linguistics.42 However, for the purpose of name generation, perfect accuracy is not the goal. The objective is to break words into plausible, pronounceable chunks that can be recombined effectively. A heuristic-based approach is therefore not a compromise but the correct engineering choice for this domain, as it provides good results without unnecessary complexity.42
We will create an editor tool script (@tool) that can process a WordListResource and output a SyllableSetResource. The logic will be a GDScript translation of a well-known heuristic algorithm based on vowel-grouping.43
The Heuristic Algorithm:
1. Define a set of characters as vowels (e.g., 'a', 'e', 'i', 'o', 'u', and sometimes 'y').
2. Iterate through a word, grouping consecutive consonants and consecutive vowels into clusters.
3. Split the word into syllables based on patterns of these clusters. A common heuristic is to split before a consonant that is followed by a vowel.
4. Handle special cases and common English spelling rules (e.g., silent 'e' at the end of a word).
This tool will allow a designer to take a list of, for example, 100 curated Elven names, run the syllabification tool, and automatically generate a SyllableSetResource containing hundreds of Elven-sounding prefixes, middles, and suffixes. This empowers the creation of infinite stylistic variations from small, high-quality source lists.

5.4. Post-Processing for Phonetic Cohesion

Even with well-curated syllable lists, random combination can sometimes produce awkward or unpronounceable results, such as three identical consonants in a row or jarring vowel combinations. To improve the quality of the output, optional post-processing rules can be applied after a name is generated.41
These rules can be implemented as a series of simple string replacements or checks:
* Rule: Disallow Triple Consonants: After generating a name, check if it contains any character repeated three or more times consecutively. If so, reduce the repetition to two (e.g., "Zarrrk" -> "Zarrk").
* Rule: Smooth Vowel Transitions: Check if a syllable ending in a vowel is followed by a syllable beginning with a vowel. If so, one of the vowels could be dropped, or a consonant could be inserted (e.g., "Aelia" might be acceptable, but "Aea" could be smoothed to "Aya").
* Rule: Prevent Invalid Combinations: Maintain a blacklist of specific letter combinations that should not appear in the final output (e.g., "qx", "zlr"). If a generated name contains a blacklisted combination, it can be discarded and a new name generated.
These post-processing steps add a final layer of polish, ensuring that the generated names are not just procedurally created but also aesthetically pleasing and phonetically sound within the context of the game's world.

Chapter 6: Strategy 3: Template-Based Generation


6.1. Concept and Use Cases

The Template-Based Generation strategy offers the highest degree of structural control. It works by defining a pattern—a template—with designated placeholders, and then filling those placeholders with content generated by other means. This approach is essential for any name or phrase that must adhere to a strict grammatical or conventional format.
While simple in concept, this strategy's true power is realized when it acts as a composition engine for the entire NameGenerator system. Instead of simply filling placeholders with words from a list, it can trigger any other generation strategy, including other templates, to create complex, nested, and hybrid results. This reframes the template strategy from a basic string-filler into the central orchestrator of the hybrid system.
Common Use Cases:
* Full Character Names: "[FirstName] '[Nickname]' [LastName]"
* Item Titles with Dynamic Properties: "[Quality][Material] of [ElementalPower]"
* Location Descriptions: "[Adjective] of the [MythicalCreature]"
* Ship Names: "[Prefix][Noun]" (e.g., "Star-Chaser")
* Action/Ability Names: "[Verb]" (e.g., "Smite Undead")

6.2. Designing the Template Syntax

A simple, readable syntax is key to making the template system usable for both programmers and designers. We will adopt a straightforward placeholder format using square brackets: [...]. The text inside the brackets acts as a key.
Example Template: The [adjective][noun] of [place_name]
Each key (adjective, noun, place_name) will correspond to an entry in a configuration dictionary that defines how to generate the content for that specific placeholder. This creates a clean separation between the template's structure and the logic used to fill it.
The following table serves as a quick reference for the syntax that will be implemented.
Table 2: Template Syntax and Placeholders
---------------------------------------------
| |Syntax Element | |Example | |Description |
---------------------------------------------
| |Placeholder | |[key] | |A placeholder to be replaced. key is a string that must exist as a key in the sub_generators dictionary of the configuration object. |
---------------------------------------------
| |Literal Text | |of the | |Any text outside of square brackets is treated as literal and will be included in the final output verbatim. |
---------------------------------------------
| |Example Template | |[title][name] | |A template to generate a titled name. The config must provide sub-generator definitions for both the title and name keys. |

6.3. TemplateStrategy.gd Implementation

The implementation of TemplateStrategy.gd will involve parsing the template string and making recursive calls back to the main NameGenerator.generate() function for each placeholder found. This recursive design is what makes the system so powerful, allowing for templates within templates. The implementation can draw inspiration from simple template parsers and Godot's built-in string manipulation and RegEx capabilities.46

GDScript


# res://name_generator/strategies/template_strategy.gd
class_name TemplateStrategy extends GeneratorStrategy

# A regular expression to find all instances of [key].
const PLACEHOLDER_REGEX = preload("res://name_generator/strategies/placeholder_regex.gd").new()

func generate(config: Dictionary, rng: RandomNumberGenerator) -> String:
    if not config.has("template_string"):
        push_error("TemplateStrategy: Configuration missing 'template_string'.")
        return ""
    if not config.has("sub_generators"):
        push_error("TemplateStrategy: Configuration missing 'sub_generators' dictionary.")
        return ""

    var template_string: String = config.template_string
    var sub_generators: Dictionary = config.sub_generators
    var result_string: String = template_string

    var matches = PLACEHOLDER_REGEX.search_all(template_string)

    for match in matches:
        # The key is the content inside the brackets (group 1 of the regex).
        var placeholder_key = match.get_string(1)
        var placeholder_full = match.get_string(0) # The full "[key]" string.

        if not sub_generators.has(placeholder_key):
            push_warning("TemplateStrategy: No sub-generator defined for key '%s'." % placeholder_key)
            continue

        # Get the configuration for the sub-generator.
        var sub_config = sub_generators[placeholder_key]

        # IMPORTANT: Make a recursive call to the main NameGenerator.
        # This allows any strategy to be used to fill a placeholder.
        var replacement_text = NameGenerator.generate(sub_config)
        
        # Replace the first occurrence of the placeholder. Using replacen with a count of 1
        # ensures that if a template has multiple identical placeholders, they are
        # generated independently.
        result_string = result_string.replacen(placeholder_full, replacement_text, 1)

    return result_string

The RegEx resource would be defined as follows:

GDScript


# res://name_generator/strategies/placeholder_regex.gd
# This script creates and compiles the RegEx object.
extends RegEx

func _init():
    # This regex finds text inside square brackets.
    # \[ and \] escape the brackets.
    # ([^\]]+) is a capturing group that matches one or more characters that are NOT a closing bracket.
    compile("\\[([^\\]]+)\\]")

This implementation demonstrates the core compositional power of the system. The TemplateStrategy does not need to know anything about how its placeholders are filled; it simply delegates the task back to the main NameGenerator, which can then invoke any other strategy—Wordlist, Syllable, Markov, or even another Template—to fulfill the request. This creates a flexible and powerful pipeline for constructing highly specific and complex names.

Chapter 7: Strategy 4: The Power of Markov Chains


7.1. Theoretical Overview

Markov Chains are stochastic models that describe a sequence of events where the probability of each event depends only on the state of the previous event.49 This "memoryless" property makes them exceptionally well-suited for generating sequences that mimic the statistical properties of a source dataset, without simply copying it.
In the context of name generation, the "events" are the characters (or groups of characters, called n-grams) in a name. The process involves two main phases:
1. Training: A large list of existing names (the training data) is analyzed to build a probability model. This model, often a dictionary or hash map, records the likelihood of any given character appearing after a specific preceding character or sequence of characters (the "state").51
2. Generation: A new name is constructed character by character by "walking" the probability model. Starting from a common initial state (e.g., the beginning of a name), the generator randomly selects the next character based on the probabilities learned during training. This new character becomes part of the new state, and the process repeats until an "end-of-name" state is reached.51
The key advantage of this method is its ability to capture the subtle phonetic and structural patterns of the source data. A model trained on Elven names will produce new names that sound Elven; a model trained on gritty, futuristic corporation names will produce new names that fit that sci-fi theme.54 This makes Markov Chains one of the most powerful and versatile techniques for generating high-quality, stylistically appropriate names.

7.2. The Training Process: A tool Script

The training phase, which involves analyzing the source data and building the probability table, can be computationally intensive for large datasets. Therefore, it should be performed offline in the editor, not at runtime. We will create an Editor Tool Script (@tool) to handle this process.
This tool script will:
1. Take a WordListResource (the training data) as input.
2. Take an integer order as a parameter. The order determines the size of the state (the number of preceding characters to consider). An order of 2 is common for name generation.
3. Parse every name in the wordlist, building a Dictionary that represents the probability model.
4. Save the resulting model into a new custom resource, MarkovModelResource.
The structure of the probability table will be a Dictionary where:
* Keys are the n-grams (strings of length order) representing the current state.
* Values are Array containing every character that was observed to follow that n-gram in the training data. The frequency of a character in this array implicitly defines its probability.
For example, with order = 2 and training data ["anna", "anne"], the table would include entries like:
* "__a": ["n", "n"] (where _ is a special start/end character)
* "_an": ["n", "n"]
* "ann": ["a", "e"]
* "nna": ["_"]
* "nne": ["_"]

7.3. The MarkovModelResource.gd

This custom resource is a simple data container for the trained model, making it easy to save, load, and assign in the editor.

GDScript


# res://name_generator/resources/markov_model_resource.gd
class_name MarkovModelResource extends Resource

## The order (n-gram size) the model was trained with.
@export var order: int = 2

## The probability table mapping n-grams to arrays of subsequent characters.
@export var probability_table: Dictionary

## A list of common starting n-grams to begin generation.
@export var start_ngrams: Array


7.4. MarkovChainStrategy.gd Implementation

The generation strategy itself is relatively simple once the model is trained. It loads the MarkovModelResource and iteratively builds a name by sampling from the probability table.

GDScript


# res://name_generator/strategies/markov_chain_strategy.gd
class_name MarkovChainStrategy extends GeneratorStrategy

const MAX_LENGTH = 20 # A safeguard against infinite loops.
const START_END_CHAR = "_"

func generate(config: Dictionary, rng: RandomNumberGenerator) -> String:
    if not config.has("model_path"):
        push_error("MarkovChainStrategy: Configuration missing 'model_path'.")
        return ""

    var model: MarkovModelResource = load(config.model_path)
    if not model:
        push_error("MarkovChainStrategy: Failed to load MarkovModelResource from '%s'." % config.model_path)
        return ""

    if model.start_ngrams.is_empty():
        push_error("MarkovChainStrategy: Model has no starting n-grams.")
        return ""

    # Start with a random valid starting n-gram.
    var current_ngram = ArrayUtils.pick_random_deterministic(model.start_ngrams, rng)
    var result_name = current_ngram.trim_prefix(START_END_CHAR.repeat(model.order))

    while result_name.length() < MAX_LENGTH:
        if not model.probability_table.has(current_ngram):
            # This can happen if the last n-gram was an end-of-word state.
            break

        var possible_next_chars: Array = model.probability_table[current_ngram]
        var next_char = ArrayUtils.pick_random_deterministic(possible_next_chars, rng)

        if next_char == START_END_CHAR:
            # We've reached the end of the name.
            break
        
        result_name += next_char
        current_ngram = current_ngram.substr(1, model.order - 1) + next_char

    return result_name.capitalize()


7.5. The "Order" Parameter

The order of the Markov chain is a critical parameter for tuning the generator's output. It represents the length of the "memory" the generator uses when predicting the next character.52
* Low Order (e.g., 1 or 2): The generator has very little context. This leads to more chaotic, random, and often creative results. The generated names will be less likely to resemble the source data directly but may also be less pronounceable or coherent.
* High Order (e.g., 4 or 5): The generator has a much longer context. This forces it to follow the patterns in the source data much more closely. The output will be highly coherent and pronounceable but may lack originality, often just reproducing segments of the names from the training set.57
Choosing the right order is a key part of balancing control and variation. An order of 2 or 3 is typically a good starting point for name generation, offering a healthy mix of stylistic consistency and novelty. This parameter should be configurable in the training tool script to allow for experimentation.

Part III: The Hybrid System & Advanced Applications

Having established and implemented the core generation strategies, the final step is to leverage the true power of our architecture: composition. This section moves beyond using the strategies in isolation and explores how they can be combined and chained together to create sophisticated, multi-layered name generation pipelines. These hybrid techniques allow for a level of nuance and control that no single algorithm could achieve on its own, fulfilling the promise of a truly universal name generator.

Chapter 8: The Hybrid Approach: Chaining Strategies for Rich Results

The architectural foundation built on the Strategy and Configuration Object patterns was deliberately chosen to facilitate composition. The TemplateStrategy already provides a powerful, data-driven way to combine generators. This chapter explores more programmatic and conceptual ways to create hybrid results, offering "recipes" for common and creative naming challenges.

8.1. Beyond Simple Templates: The HybridStrategy

While templates are excellent for declarative composition, a more programmatic approach can be useful for complex, multi-step generation processes. A dedicated HybridStrategy can be implemented to execute a sequence of generation configurations, where the output of one step can be used in the next. This formalizes the concept of a generation pipeline, a common pattern in procedural content generation.3
The HybridStrategy's configuration would take an array of sub-configurations to be executed in order. A special syntax could be used to pass results between steps. For example, a result from step 0 could be referenced as $0 in the configuration for step 1. This allows for powerful, dynamic chains of generation.

8.2. Practical Hybridization Recipes

The following recipes demonstrate how different strategies can be combined to achieve results that are more refined and specific than any single strategy could produce alone. These examples can be implemented using either the TemplateStrategy or a more advanced HybridStrategy.

Recipe 1: Markov Root with Syllabic Suffix

* Goal: Generate a name that has the strong stylistic core of a Markov chain but guarantees a specific type of ending.
* Method:
	1. Use the MarkovChainStrategy to generate a base name, but configure it with a model trained on names that have their final syllables removed. This creates a strong "root." (e.g., "Zarth", "Krag").
	2. Use the SyllableChainStrategy to generate only a suffix by providing a SyllableSetResource where the prefix and middle arrays are empty. (e.g., "ian", "or").
	3. Concatenate the results.
* Result: "Zarthian", "Kragor". This hybrid approach provides the stylistic flavor of the Markov chain with the structural guarantee of the syllable system.

Recipe 2: The Full-Featured Template

* Goal: Generate a complete, titled character name with multiple procedurally generated components.
* Method: Use the TemplateStrategy with a rich configuration that makes nested calls to other generators.
	* Template String: "[title][firstname] of the [place]"
	* Configuration:
GDScript
{
    "strategy": "template",
    "seed": "unique_npc_seed_123",
    "template_string": "[title][firstname] of the [place]",
    "sub_generators": {
        "title": {
            "strategy": "wordlist",
            "seed": "unique_npc_seed_123_title",
            "wordlist_paths": ["res://data/wordlists/people/titles.tres"]
        },
        "firstname": {
            "strategy": "markov",
            "seed": "unique_npc_seed_123_firstname",
            "model_path": "res://data/markov_models/fantasy_male.tres"
        },
        "place": {
            "strategy": "template",
            "seed": "unique_npc_seed_123_place",
            "template_string": "[adjective][location]",
            "sub_generators": {
                "adjective": {... config for wordlist... },
                "location": {... config for wordlist... }
            }
        }
    }
}

* Result: "Baron Alaric of the Whispering Peaks". This demonstrates the power of recursive templates to build complex strings from multiple, independently generated parts.

Recipe 3: Simulating Cluster Chaining

* Goal: Create names with a strict alternating vowel-consonant structure, simulating advanced algorithms like Cluster Chaining.59
* Method:
	1. Data Preparation: Create two separate WordListResource files. One contains only vowel clusters ("a", "e", "i", "o", "u", "ae", "ou") and the other contains only consonant clusters ("b", "tr", "st", "nd").
	2. Model Training: Train two separate MarkovModelResource files. vowel_model.tres is trained on the vowel list, and consonant_model.tres is trained on the consonant list. This teaches each model the statistical patterns within its character set.
	3. Generation: Programmatically alternate calls to the NameGenerator, once using the consonant model and once using the vowel model, stitching the results together.
* Result: A name like "Stronar" or "Venduul". This technique leverages the stylistic learning of Markov chains but imposes a rigid, externally defined structure, offering a unique blend of control and variation.

Chapter 9: Finalizing and Integrating the NameGenerator


9.1. Creating a User-Friendly API

While the core generate(config) method is powerful and flexible, it can be verbose for common, repeated tasks. To create a more user-friendly API, the NameGenerator singleton should include a set of helper functions for the most frequent name requests.
These helper functions would encapsulate the creation of the configuration dictionary, making the call a simple one-liner from other parts of the game code.

GDScript


# In NameGenerator.gd
#...

func generate_fantasy_elf_male(p_seed: String) -> String:
    var config = {
        "strategy": "syllable",
        "seed": p_seed,
        "syllable_set_path": "res://data/syllable_sets/fantasy_elven.tres",
        "middle_syllables": 1
    }
    return generate(config)

func generate_iron_sword(p_seed: String) -> String:
    var config = {
        "strategy": "wordlist",
        "seed": p_seed,
        "wordlist_paths": [
            "res://data/wordlists/objects/quality_common.tres",
            "res://data/wordlists/objects/material_iron.tres",
            "res://data/wordlists/objects/weapon_types_swords.tres"
        ]
    }
    return generate(config)

These helpers abstract away the complexity of the configuration object, providing simple, clear entry points for common use cases while retaining the full power of the underlying system for more complex, custom needs.

9.2. In-Game Integration Examples

The true value of the NameGenerator is realized when it is integrated into other game systems to dynamically create content.
* NPC Factory: An NPC spawning system can use the generator to ensure every NPC has a unique, deterministic name. The seed can be derived from a combination of the world seed and the NPC's spawn position or a unique ID.
GDScript
# In an NPC Spawner script
func spawn_npc(id: int, position: Vector2):
    var npc_scene = preload("res://actors/npc.tscn").instantiate()

    # Generate a deterministic seed for this specific NPC.
    var npc_seed = "%s_npc_%d" %

    npc_scene.set_name(NameGenerator.generate_fantasy_elf_male(npc_seed))
    npc_scene.global_position = position
    add_child(npc_scene)

* Loot System: When an enemy is defeated, a loot generation system can create an item and use the NameGenerator to give it a name that reflects its procedurally generated stats.
GDScript
# In a LootDrop script
func generate_loot(base_item: ItemResource, rng: RandomNumberGenerator):
    var item_stats = _generate_random_stats(base_item, rng)

    # Create a config for the name based on the generated stats.
    var name_config = _build_name_config_from_stats(item_stats)

    # Use the item's unique instance ID as part of the seed.
    var item_seed = "item_drop_%d" % item_stats.instance_id
    name_config["seed"] = item_seed

    var item_name = NameGenerator.generate(name_config)
    #... create the item with the generated name and stats.

* World Generation: During the initial creation of the game world, the NameGenerator can be used to name continents, cities, rivers, and dungeons. By deriving all seeds from the single master world seed, the entire world, including all its names, becomes fully reproducible.

9.3. Performance and Future Extensibility

The performance cost of the generation process is generally very low and suitable for real-time use. The most computationally expensive operation is the training of Markov Chain models, which is designed to be an offline, editor-only task. The runtime generation for all implemented strategies primarily involves dictionary lookups and string operations, which are extremely fast.
The true architectural strength of the system lies in its extensibility. The Strategy pattern ensures that the NameGenerator is future-proof. As new and more advanced procedural generation techniques emerge—such as those based on neural networks or large language models 36—they can be integrated into the system seamlessly. A developer would only need to write a new
GeneratorStrategy class (e.g., LlmStrategy.gd) that implements the generate method and handles communication with the new model, and then register it in the NameGenerator's _ready function. The rest of the game's code, which calls the NameGenerator API, would require no modification to begin using this new, powerful technique. This modularity ensures the system can evolve alongside the field of procedural generation itself.

Appendix A: Curated Wordlist Resources

The quality of the names produced by the NameGenerator is directly proportional to the quality of the input data. This appendix provides guidance on finding, formatting, and licensing wordlists for use with the system.

Licensing: A Critical Consideration

It is imperative to verify the license of any wordlist or dataset before incorporating it into a project, especially a commercial one. Many excellent resources compiled for tabletop role-playing games or academic purposes are not licensed for commercial use.
A prominent example is Kate Monk's Onomastikon, a vast and well-regarded collection of historical and cultural names.60 While an invaluable resource for personal use, its license explicitly states:
"Copies may be made for personal use only".61 This means its contents cannot be legally distributed as part of a commercial game. Always look for a clear license file (e.g., MIT, CC0, Apache 2.0) or a public domain declaration. When in doubt, assume the data is not free to use commercially.

Recommended Open Source Collections

The following are types of resources and specific repositories that often provide data under permissive, open-source licenses suitable for game development.
* General Purpose Wordlists for Games:
	* Wordnik Wordlist: An open-source list of English words specifically curated for game developers. Licensed under MIT.65
	* DandyLyons/WordLists: A collection of permissively licensed wordlists for use in games, with clear licensing information for each source file.66
	* tube42/wordlists: A collection of multi-language word lists intended for open-source games, though the license is GPLv2, which has specific requirements for projects that use it.67
* Real-World Name Datasets:
	* U.S. Census Data: The United States Census Bureau provides public domain lists of common first names and surnames, which are excellent for generating realistic modern names.
	* philipperemy/name-dataset: A massive dataset of over 490 million records from 106 countries, available as CSV files. The code is Apache-2.0 licensed, but the data itself is derived from a public data leak, and the author notes that "Lists of names are not copyrightable, generally speaking, but if you want to be completely sure you should talk to a lawyer".68
* Fantasy & Sci-Fi Name Generators (for inspiration and data mining):
	* While many online generators do not provide their source lists, some open-source projects on GitHub do. These can be valuable sources for syllable lists or Markov chain training data, provided their licenses are permissive.
	* donjon.bin.sh: Offers extensive, categorized name lists for fantasy and sci-fi settings. While it doesn't offer direct downloads, the lists can be scraped for personal projects. The site uses the Open Gaming License for some content, but the license for the name lists themselves is not explicitly stated.69
	* GitHub Topic Searches: Searching GitHub for topics like "fantasy-names" 70, "name-generator" 71, or "wordlist" 72 can reveal numerous repositories. Always inspect the
LICENSE file in each repository before using its data. Examples include skeeto/fantasyname (Unlicense) 73 and
roryok/scifi-name-generator (license unclear, but contains a data.json file).74
By carefully selecting high-quality, appropriately licensed data, you can unlock the full potential of the Universal Name Generator to create rich, diverse, and memorable names for every aspect of your game world.
Works cited
1. Procedural Content Generation Using Patterns as Objectives - ResearchGate, accessed September 17, 2025, https://www.researchgate.net/publication/260475455_Procedural_Content_Generation_Using_Patterns_as_Objectives(https://www.researchgate.net/publication/260475455_Procedural_Content_Generation_Using_Patterns_as_Objectives)
2. Procedural Worlds? Forget Level Design. - Wayline, accessed September 17, 2025, https://www.wayline.io/blog/procedural-worlds-forget-level-design(https://www.wayline.io/blog/procedural-worlds-forget-level-design)
3. A Hybrid Approach to Procedural Generation of Roguelike Video Game Levels, accessed September 17, 2025, https://www.researchgate.net/publication/346720996_A_Hybrid_Approach_to_Procedural_Generation_of_Roguelike_Video_Game_Levels(https://www.researchgate.net/publication/346720996_A_Hybrid_Approach_to_Procedural_Generation_of_Roguelike_Video_Game_Levels)
4. Random Names Generator - Godot Asset Library, accessed September 17, 2025, https://godotengine.org/asset-library/asset/1760(https://godotengine.org/asset-library/asset/1760)
5. Godot Name Generator released - Cerol, accessed September 17, 2025, https://cerol.itch.io/godot-name-generator-class/devlog/813493/godot-name-generator-released(https://cerol.itch.io/godot-name-generator-class/devlog/813493/godot-name-generator-released)
6. marcosbitetti/godot_procedural_name_generator: Name generator - GitHub, accessed September 17, 2025, https://github.com/marcosbitetti/godot_procedural_name_generator(https://github.com/marcosbitetti/godot_procedural_name_generator)
7. Name generator - Godot Asset Library, accessed September 17, 2025, https://godotengine.org/asset-library/asset/87(https://godotengine.org/asset-library/asset/87)
8. Table of Contents - Game Programming Patterns, accessed September 17, 2025, https://gameprogrammingpatterns.com/contents.html(https://gameprogrammingpatterns.com/contents.html)
9. Design Patterns for games, best practices ? : r/gamedev - Reddit, accessed September 17, 2025, https://www.reddit.com/r/gamedev/comments/wxca7i/design_patterns_for_games_best_practices/(https://www.reddit.com/r/gamedev/comments/wxca7i/design_patterns_for_games_best_practices/)
10. Design patterns in Godot - GDQuest, accessed September 17, 2025, https://www.gdquest.com/tutorial/godot/design-patterns/intro-to-design-patterns/(https://www.gdquest.com/tutorial/godot/design-patterns/intro-to-design-patterns/)
11. Resolvi: A Reference Architecture for Extensible, Scalable and Interoperable Entity Resolution - arXiv, accessed September 17, 2025, https://arxiv.org/html/2503.08087v3(https://arxiv.org/html/2503.08087v3)
12. My architectural addons for mid-to-large games - Plugins - Godot Forum, accessed September 17, 2025, https://forum.godotengine.org/t/my-architectural-addons-for-mid-to-large-games/97552(https://forum.godotengine.org/t/my-architectural-addons-for-mid-to-large-games/97552)
13. Procedural Map Generation with Godot — Part 1 - Medium, accessed September 17, 2025, https://medium.com/pumpkinbox-blog/procedural-map-generation-with-godot-part-1-1b4e78191e90(https://medium.com/pumpkinbox-blog/procedural-map-generation-with-godot-part-1-1b4e78191e90)
14. Layered procedural generation for complex world generation : r/godot - Reddit, accessed September 17, 2025, https://www.reddit.com/r/godot/comments/1b4lhp3/layered_procedural_generation_for_complex_world/(https://www.reddit.com/r/godot/comments/1b4lhp3/layered_procedural_generation_for_complex_world/)
15. gdquest-demos/godot-procedural-generation: Procedural ... - GitHub, accessed September 17, 2025, https://github.com/gdquest-demos/godot-procedural-generation(https://github.com/gdquest-demos/godot-procedural-generation)
16. Procedural Map Generation with Godot — Part 2 | by Rami Awar | PumpkinBox Blog, accessed September 17, 2025, https://medium.com/pumpkinbox-blog/procedural-map-generation-with-godot-part-2-dc8196cc3e57(https://medium.com/pumpkinbox-blog/procedural-map-generation-with-godot-part-2-dc8196cc3e57)
17. Procedural terrain generation system I'm building in Godot - Reddit, accessed September 17, 2025, https://www.reddit.com/r/godot/comments/1lsbqk7/procedural_terrain_generation_system_im_building/(https://www.reddit.com/r/godot/comments/1lsbqk7/procedural_terrain_generation_system_im_building/)
18. [Tutorial] Singleton Design Pattern in Godot - Reddit, accessed September 17, 2025, https://www.reddit.com/r/godot/comments/1bdqfq5/tutorial_singleton_design_pattern_in_godot/(https://www.reddit.com/r/godot/comments/1bdqfq5/tutorial_singleton_design_pattern_in_godot/)
19. Saving/loading data :: Godot 4 Recipes - KidsCanCode, accessed September 17, 2025, https://kidscancode.org/godot_recipes/4.x/basics/file_io/index.html(https://kidscancode.org/godot_recipes/4.x/basics/file_io/index.html)
20. FileAccess — Godot Engine (4.4) documentation in English, accessed September 17, 2025, https://docs.godotengine.org/en/4.4/classes/class_fileaccess.html(https://docs.godotengine.org/en/4.4/classes/class_fileaccess.html)
21. How to read sections of a text file? - godot - Reddit, accessed September 17, 2025, https://www.reddit.com/r/godot/comments/hemsr4/how_to_read_sections_of_a_text_file/(https://www.reddit.com/r/godot/comments/hemsr4/how_to_read_sections_of_a_text_file/)
22. Can you read a TextFile resource with GDScript? - Archive - Godot Forum, accessed September 17, 2025, https://forum.godotengine.org/t/can-you-read-a-textfile-resource-with-gdscript/22949(https://forum.godotengine.org/t/can-you-read-a-textfile-resource-with-gdscript/22949)
23. Getting text from .txt files - Godot Forums, accessed September 17, 2025, https://godotforums.org/d/30338-getting-text-from-txt-files(https://godotforums.org/d/30338-getting-text-from-txt-files)
24. How to import and read text? - Archive - Godot Forum, accessed September 17, 2025, https://forum.godotengine.org/t/how-to-import-and-read-text/21936(https://forum.godotengine.org/t/how-to-import-and-read-text/21936)
25. (Venting) Godot's handling of CSV files is dumb. - Reddit, accessed September 17, 2025, https://www.reddit.com/r/godot/comments/1micym8/venting_godots_handling_of_csv_files_is_dumb/(https://www.reddit.com/r/godot/comments/1micym8/venting_godots_handling_of_csv_files_is_dumb/)
26. JSON — Godot Engine (4.4) documentation in English, accessed September 17, 2025, https://docs.godotengine.org/en/4.4/classes/class_json.html(https://docs.godotengine.org/en/4.4/classes/class_json.html)
27. Resources — Godot Engine (4.4) documentation in English, accessed September 17, 2025, https://docs.godotengine.org/en/4.4/tutorials/scripting/resources.html(https://docs.godotengine.org/en/4.4/tutorials/scripting/resources.html)
28. Custom Resource are a MUST KNOW in Godot | Complete Tutorial - YouTube, accessed September 17, 2025, https://www.youtube.com/watch?v=zbAKzM-Odb4(https://www.youtube.com/watch?v=zbAKzM-Odb4)
29. Custom Resources in Godot Engine 4.x - Simon Dalvai, accessed September 17, 2025, https://simondalvai.org/blog/godot-custom-resources/(https://simondalvai.org/blog/godot-custom-resources/)
30. Dictionary or Resource Database? - Godot Forums, accessed September 17, 2025, https://godotforums.org/d/33141-dictionary-or-resource-database(https://godotforums.org/d/33141-dictionary-or-resource-database)
31. Custom Resources in Godot 4 and How to use them - YouTube, accessed September 17, 2025, https://www.youtube.com/watch?v=NuLSYHK-8Yg(https://www.youtube.com/watch?v=NuLSYHK-8Yg)
32. How to export an array of Resources and edit them in the Inspector? : r/godot - Reddit, accessed September 17, 2025, https://www.reddit.com/r/godot/comments/11tn48h/how_to_export_an_array_of_resources_and_edit_them/(https://www.reddit.com/r/godot/comments/11tn48h/how_to_export_an_array_of_resources_and_edit_them/)
33. Top Game Development Patterns in Godot Engine - Manuel Sánchez, accessed September 17, 2025, https://www.manuelsanchezdev.com/blog/game-development-patterns(https://www.manuelsanchezdev.com/blog/game-development-patterns)
34. How to Make Your Game Deterministic (and Why) : r/godot - Reddit, accessed September 17, 2025, https://www.reddit.com/r/godot/comments/1ix4rcl/how_to_make_your_game_deterministic_and_why/(https://www.reddit.com/r/godot/comments/1ix4rcl/how_to_make_your_game_deterministic_and_why/)
35. By Design: Procedural Generation - SUPERJUMP, accessed September 17, 2025, https://www.superjumpmagazine.com/by-design-procedural-generation/(https://www.superjumpmagazine.com/by-design-procedural-generation/)
36. Procedural generation - Wikipedia, accessed September 17, 2025, https://en.wikipedia.org/wiki/Procedural_generation(https://en.wikipedia.org/wiki/Procedural_generation)
37. Random number generator seed mistakes & how to seed an RNG : r/programming - Reddit, accessed September 17, 2025, https://www.reddit.com/r/programming/comments/43tyci/random_number_generator_seed_mistakes_how_to_seed/(https://www.reddit.com/r/programming/comments/43tyci/random_number_generator_seed_mistakes_how_to_seed/)
38. RandomNumberGenerator — Godot Engine (4.4) documentation in English, accessed September 17, 2025, https://docs.godotengine.org/en/4.4/classes/class_randomnumbergenerator.html(https://docs.godotengine.org/en/4.4/classes/class_randomnumbergenerator.html)
39. How do I replicate RandomNumberGenerator output with a seed? - Archive - Godot Forum, accessed September 17, 2025, https://forum.godotengine.org/t/how-do-i-replicate-randomnumbergenerator-output-with-a-seed/18344(https://forum.godotengine.org/t/how-do-i-replicate-randomnumbergenerator-output-with-a-seed/18344)
40. Name Generator with lists | OpenGameArt.org, accessed September 17, 2025, https://opengameart.org/content/name-generator-with-lists(https://opengameart.org/content/name-generator-with-lists)
41. Syllable-based name generation - RogueBasin, accessed September 17, 2025, https://www.roguebasin.com/index.php/Syllable-based_name_generation(https://www.roguebasin.com/index.php/Syllable-based_name_generation)
42. Text Compression: Syllables, accessed September 17, 2025, http://ftp.informatik.rwth-aachen.de/Publications/CEUR-WS/Vol-129/paper6.pdf(http://ftp.informatik.rwth-aachen.de/Publications/CEUR-WS/Vol-129/paper6.pdf)
43. nlp - Detecting syllables in a word - Stack Overflow, accessed September 17, 2025, https://stackoverflow.com/questions/405161/detecting-syllables-in-a-word(https://stackoverflow.com/questions/405161/detecting-syllables-in-a-word)
44. Automatic syllabification in English: a comparison of different algorithms - PubMed, accessed September 17, 2025, https://pubmed.ncbi.nlm.nih.gov/19334414/(https://pubmed.ncbi.nlm.nih.gov/19334414/)
45. Counting Syllables In A Word - Stack Overflow, accessed September 17, 2025, https://stackoverflow.com/questions/9096228/counting-syllables-in-a-word(https://stackoverflow.com/questions/9096228/counting-syllables-in-a-word)
46. GDScript format strings — Godot Engine (4.4) documentation in English, accessed September 17, 2025, https://docs.godotengine.org/en/4.4/tutorials/scripting/gdscript/gdscript_format_string.html(https://docs.godotengine.org/en/4.4/tutorials/scripting/gdscript/gdscript_format_string.html)
47. String — Godot Engine (4.4) documentation in English, accessed September 17, 2025, https://docs.godotengine.org/en/4.4/classes/class_string.html(https://docs.godotengine.org/en/4.4/classes/class_string.html)
48. Simple Text File Resource + Template Engine - General - Godot ..., accessed September 17, 2025, https://forum.godotengine.org/t/simple-text-file-resource-template-engine/82499(https://forum.godotengine.org/t/simple-text-file-resource-template-engine/82499)
49. Markov chain - Wikipedia, accessed September 17, 2025, https://en.wikipedia.org/wiki/Markov_chain(https://en.wikipedia.org/wiki/Markov_chain)
50. Fiction names generator using a Markov chain algorithm - microStudio, accessed September 17, 2025, https://microstudio.dev/community/project-sharing/fiction-names-generator-using-a-markov-chain-algorithm/72/(https://microstudio.dev/community/project-sharing/fiction-names-generator-using-a-markov-chain-algorithm/72/)
51. Name Generator Tutorial. based on Markov Model | by Oleg ..., accessed September 17, 2025, https://medium.com/@PuchkovOleg/name-generator-tutorial-1c9a3dfb2ab0(https://medium.com/@PuchkovOleg/name-generator-tutorial-1c9a3dfb2ab0)
52. Markov Name Generation · luetkemj, accessed September 17, 2025, https://luetkemj.github.io/170102/2016-markov-name-generation/(https://luetkemj.github.io/170102/2016-markov-name-generation/)
53. Markov Chains and Names - Endless Prose by logicandchaos - Itch.io, accessed September 17, 2025, https://logicandchaos.itch.io/endless-prose/devlog/491155/markov-chains-and-names(https://logicandchaos.itch.io/endless-prose/devlog/491155/markov-chains-and-names)
54. Random name generation using Markov chains : r/proceduralgeneration - Reddit, accessed September 17, 2025, https://www.reddit.com/r/proceduralgeneration/comments/m30452/random_name_generation_using_markov_chains/(https://www.reddit.com/r/proceduralgeneration/comments/m30452/random_name_generation_using_markov_chains/)
55. I created a short tutorial on how to use Markov models to generate random names. Markov models are surprisingly simple and just changing datasets can produce entirely different naming styles. Great for adding depth to your game worlds or creative projects. - Reddit, accessed September 17, 2025, https://www.reddit.com/r/processing/comments/1m3jzvg/i_created_a_short_tutorial_on_how_to_use_markov/(https://www.reddit.com/r/processing/comments/1m3jzvg/i_created_a_short_tutorial_on_how_to_use_markov/)
56. A short tutorial on using Markov models to generate realistic-sounding names. A major advantage of Markov models is that by simply changing datasets you can produce entirely different naming styles. Making them useful for adding depth to your game worlds or other creative projects. : r/proceduralgeneration - Reddit, accessed September 17, 2025, https://www.reddit.com/r/proceduralgeneration/comments/1m3jyh5/a_short_tutorial_on_using_markov_models_to/(https://www.reddit.com/r/proceduralgeneration/comments/1m3jyh5/a_short_tutorial_on_using_markov_models_to/)
57. Using a Markov chain to generate readable nonsense with 20 lines of Python - Ben Hoyt, accessed September 17, 2025, https://benhoyt.com/writings/markov-chain/(https://benhoyt.com/writings/markov-chain/)
58. IORand: A Procedural Videogame Level Generator Based on a Hybrid PCG Algorithm, accessed September 17, 2025, https://www.mdpi.com/2076-3417/12/8/3792(https://www.mdpi.com/2076-3417/12/8/3792)
59. Cluster chaining name generator - RogueBasin, accessed September 17, 2025, https://www.roguebasin.com/index.php/Cluster_chaining_name_generator(https://www.roguebasin.com/index.php/Cluster_chaining_name_generator)
60. The Alexandrian » Fantasy Names, accessed September 17, 2025, https://thealexandrian.net/wordpress/24620/roleplaying-games/fantasy-names(https://thealexandrian.net/wordpress/24620/roleplaying-games/fantasy-names)
61. KateMonk - tekeli.li, accessed September 17, 2025, https://tekeli.li/onomastikon/(https://tekeli.li/onomastikon/)
62. Kate Monk's Onomastikon: A Far Better Gamer Resource Than Fantasy Name Generators., accessed September 17, 2025, https://www.reddit.com/r/rpg/comments/xoeeg/kate_monks_onomastikon_a_far_better_gamer/(https://www.reddit.com/r/rpg/comments/xoeeg/kate_monks_onomastikon_a_far_better_gamer/)
63. Thread: Kate Monk's Onamastikon - Totalwar.org, accessed September 17, 2025, https://forums.totalwar.org/vb/showthread.php/39948-Kate-Monk-s-Onamastikon(https://forums.totalwar.org/vb/showthread.php/39948-Kate-Monk-s-Onamastikon)
64. Kate Monk's Onomastikon - tekeli.li, accessed September 17, 2025, https://tekeli.li/onomastikon/Index/Introduction.html(https://tekeli.li/onomastikon/Index/Introduction.html)
65. wordnik/wordlist: an open-source wordlist for game developers and others - GitHub, accessed September 17, 2025, https://github.com/wordnik/wordlist(https://github.com/wordnik/wordlist)
66. DandyLyons/WordLists: Load word lists for use in word games and other purposes. - GitHub, accessed September 17, 2025, https://github.com/DandyLyons/WordLists(https://github.com/DandyLyons/WordLists)
67. tube42/wordlists: Multi-language word lists for use in open source games. - GitHub, accessed September 17, 2025, https://github.com/tube42/wordlists(https://github.com/tube42/wordlists)
68. philipperemy/name-dataset: The Python library for names. - GitHub, accessed September 17, 2025, https://github.com/philipperemy/name-dataset(https://github.com/philipperemy/name-dataset)
69. donjon; Fantasy Name Generator, accessed September 17, 2025, https://donjon.bin.sh/fantasy/name/(https://donjon.bin.sh/fantasy/name/)
70. Gregory-Jagermeister/Fantasy-Content-Generator: a ... - GitHub, accessed September 17, 2025, https://github.com/Gregory-Jagermeister/Fantasy-Content-Generator(https://github.com/Gregory-Jagermeister/Fantasy-Content-Generator)
71. name-generator · GitHub Topics, accessed September 17, 2025, https://github.com/topics/name-generator(https://github.com/topics/name-generator)
72. word-list · GitHub Topics, accessed September 17, 2025, https://github.com/topics/word-list(https://github.com/topics/word-list)
73. skeeto/fantasyname: Fantasy name generator - GitHub, accessed September 17, 2025, https://github.com/skeeto/fantasyname(https://github.com/skeeto/fantasyname)
74. roryok/scifi-name-generator - GitHub, accessed September 17, 2025, https://github.com/roryok/scifi-name-generator(https://github.com/roryok/scifi-name-generator)

